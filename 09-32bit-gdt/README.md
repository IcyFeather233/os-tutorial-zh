*你可能想在之前Google的概念：GDT*

**目标：编程GDT**

还记得第六课的分段吗？偏移量被左移以处理额外的间接层。

在32位模式下，分段的工作方式不同。现在，偏移量变成了GDT中段描述符（SD）的索引。这个描述符定义了基地址（32位）、大小（20位）和一些标志，如只读、权限等。为了增加混淆，数据结构是分开的，所以打开os-dev.pdf文件并查看第34页的图表或GDT的Wikipedia页面。

编程GDT的最简单方法是定义两个段，一个用于代码，另一个用于数据。这些可以重叠，这意味着没有内存保护，但对于启动来说已经足够了，我们稍后会用更高级别的语言来修复这个问题。

作为一个好奇点，第一个GDT条目必须是`0x00`，以确保程序员在管理地址时没有犯任何错误。

此外，CPU不能直接加载GDT地址，而是需要一个称为“GDT描述符”的元结构，其中包含我们实际GDT的大小（16位）和地址（32位）。它通过`lgdt`操作加载。

让我们直接跳到汇编中的GDT代码。同样，要理解所有段标志，请参考os-dev.pdf文档。本课的理论非常复杂。

在下一课中，我们将切换到32位保护模式，并测试这些课程中的代码。

`nasm -fbin 32bit-gdt.asm -o 32bit-gdt.bin`

`qemu 32bit-gdt.bin` 或 `qemu-system-x86_64 32bit-gdt.bin`