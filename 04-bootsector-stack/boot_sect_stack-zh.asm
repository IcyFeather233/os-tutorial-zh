; 设置 TTY 模式，用于在屏幕上显示字符
mov ah, 0x0e ; 设置 AH 寄存器为 0x0e，表示使用 TTY 模式

; 设置栈指针
mov bp, 0x8000 ; 将基址指针 BP 设置为 0x8000，这是一个远离 0x7c00 的地址，以避免被覆盖
mov sp, bp ; 将栈指针 sp 设置为 0x8000，栈底指针 bp 也设置为 0x8000。

; 将字符 'A', 'B', 'C' 压入栈中
push 'A' ; 将字符 'A' 压入栈中
push 'B' ; 将字符 'B' 压入栈中
push 'C' ; 将字符 'C' 压入栈中

; 依次将字符 'A', 'B', 'C' 压入栈中。由于栈是向下增长的，栈顶指针 sp 会依次减少：
; 压入 'A' 后，sp 指向 0x7ffE
; 压入 'B' 后，sp 指向 0x7ffC
; 压入 'C' 后，sp 指向 0x7ffA

; 显示栈是如何向下增长的
mov al, [0x7ffe] ; 将地址 0x7ffe（即 0x8000 - 2）处的值加载到 AL 寄存器中
int 0x10 ; 调用 BIOS 中断 0x10，显示 AL 中的字符
; 显示 A

; 注意：现在不要尝试访问 [0x8000]，因为这不会起作用
; 你只能访问栈顶，此时只能访问 0x7ffe（见上文）
mov al, [0x8000] ; 尝试访问地址 0x8000 处的值
int 0x10 ; 调用 BIOS 中断 0x10，显示 AL 中的字符
; 尝试访问地址 0x8000 处的值，但由于栈顶指针已经移动，这个地址处的值是未定义的，因此不会显示任何有意义的字符

; 使用标准过程 'pop' 恢复我们的字符
; 我们只能弹出完整的字（两个字节），因此需要一个辅助寄存器来操作低字节
pop bx ; 从栈中弹出一个字到 BX 寄存器
mov al, bl ; 将 BX 寄存器的低字节（即字符 'C'）加载到 AL 寄存器中
int 0x10 ; 调用 BIOS 中断 0x10，显示 AL 中的字符
; 显示 C

pop bx ; 从栈中弹出一个字到 BX 寄存器
mov al, bl ; 将 BX 寄存器的低字节（即字符 'B'）加载到 AL 寄存器中
int 0x10 ; 调用 BIOS 中断 0x10，显示 AL 中的字符
; 显示 B

pop bx ; 从栈中弹出一个字到 BX 寄存器
mov al, bl ; 将 BX 寄存器的低字节（即字符 'A'）加载到 AL 寄存器中
int 0x10 ; 调用 BIOS 中断 0x10，显示 AL 中的字符
; 显示 A

; 从栈中弹出的数据现在是无用的
mov al, [0x8000] ; 尝试访问地址 0x8000 处的值
int 0x10 ; 调用 BIOS 中断 0x10，显示 AL 中的字符
; 再次尝试访问地址 0x8000 处的值，但由于栈顶指针已经移动，这个地址处的值仍然是未定义的，因此不会显示任何有意义的字符。

; 无限循环
jmp $ ; 跳转到当前指令，形成无限循环

; 填充引导扇区
times 510-($-$$) db 0 ; 填充剩余的字节，使总大小为 512 字节
dw 0xaa55 ; 设置引导扇区标志